// src/lib.rs

// 1. The FFI Bridge Definition
#[cxx::bridge]
mod ffi {
    // The 'extern "C++"' block MUST be marked 'unsafe' if it contains
    // functions that use raw pointers (*const T or *mut T).
    extern "C++" {
        include!("compute_core/math_core.h");

        // FIX: The function signatures must be inside an 'unsafe' block
        // when using raw pointers (*const T or *mut T).
        unsafe fn perform_matrix_vector_multiplication(
            matrix_ptr: *const f64,
            vector_ptr: *const f64,
            output_ptr: *mut f64,
            dim: usize,
        );
    }
}

// 2. The Safe Rust API (The Gatekeeper)
pub fn calculate_matrix_vector_product(
    matrix_flat: &[f64],
    vector_in: &[f64],
    dim: usize,
) -> Result<Vec<f64>, String> {
    // Input Validation (Security-First Defaults)
    let expected_matrix_len = dim * dim;
    if matrix_flat.len() != expected_matrix_len {
        return Err(format!("Matrix size mismatch: Expected {} elements ({}x{}) but found {}", 
            expected_matrix_len, dim, dim, matrix_flat.len()));
    }
    if vector_in.len() != dim {
        return Err(format!("Vector size mismatch: Expected {} elements but found {}", 
            dim, vector_in.len()));
    }

    // Strict Ownership Model: Rust allocates and owns the result vector memory
    let mut vector_out = vec![0.0; dim];

    // FFI Call: We borrow the memory as raw pointers for the C++ function's scope only.
    unsafe {
        ffi::perform_matrix_vector_multiplication(
            matrix_flat.as_ptr(),
            vector_in.as_ptr(),
            vector_out.as_mut_ptr(),
            dim,
        );
    }

    Ok(vector_out)
}

// 3. FFI Integration Tests
#[cfg(test)]
mod tests {
    use super::*;

    // M * V = [2, 0; 0, 3] * [4, 5] = [8, 15]
    #[test]
    fn test_matrix_vector_multiplication_success() {
        let dim = 2;
        let matrix_flat = vec![2.0, 0.0, 0.0, 3.0]; 
        let vector_in = vec![4.0, 5.0];             

        let result = calculate_matrix_vector_product(&matrix_flat, &vector_in, dim);

        assert!(result.is_ok(), "Calculation failed: {:?}", result.err());
        let output = result.unwrap();
        
        let epsilon = 1e-9; 
        assert!((output[0] - 8.0).abs() < epsilon, "Element 0 failed. Got {}", output[0]);
        assert!((output[1] - 15.0).abs() < epsilon, "Element 1 failed. Got {}", output[1]);
    }

    #[test]
    fn test_input_validation_error() {
        let dim = 3; 
        let matrix_flat = vec![1.0; 8]; // Wrong size (expected 9)
        let vector_in = vec![1.0; 3];

        let result = calculate_matrix_vector_product(&matrix_flat, &vector_in, dim);
        
        assert!(result.is_err());
        assert!(result.unwrap_err().contains("Matrix size mismatch"));
    }
}

