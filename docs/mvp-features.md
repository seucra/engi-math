|1. Linear Algebra Solver	|C++ (Compute)	|User inputs a large matrix (e.g., 100x100). Rust validates the dimensions (A-OK). C++ calculates the determinant/eigenvalues quickly. Rust validates the result before display.|
|2. ODE/PDE Solver	|C++ (Compute) + Qt (UI)	|C++ implements a heavy numerical integration method (e.g., Runge-Kutta 4th order). Qt plots the resulting data points, which were safely passed back from C++ through Rust.|
|3. Progress & State	|Rust (Core Logic) + Database	|Rust manages the application state (what problems the user has solved, settings). Rust writes and reads to a local database (e.g., SQLite via a safe Rust crate) or a simple config file, enforcing Threading Discipline if necessary.|
|4. Error Reporting	|Rust (Error Handling)	|If C++ encounters an issue (e.g., a non-invertible matrix), it returns a specific error code to Rust. Rust maps this code to a descriptive error type (Result<T, E>) and safely presents a user-friendly error message in the Qt UI.|
